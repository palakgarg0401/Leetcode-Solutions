// Count Unguarded Cells in the Grid

// Approach 1
class Solution {
    private void markGuarded(int[][] grid, int m, int n){
        boolean[][] guarded = new boolean[m][n];
        // left -> right
        for(int i = 0; i < m; i++){
            boolean seen = false;
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 2) seen = false;
                else if(grid[i][j] == 1) seen = true;
                else if(seen) guarded[i][j] = true;
            }
        }

        // right -> left
        for(int i = 0; i < m; i++){
            boolean seen = false;
            for(int j = n - 1; j >= 0; j--){
                if(grid[i][j] == 2) seen = false;
                else if(grid[i][j] == 1) seen = true;
                else if(seen) guarded[i][j] = true;
            }
        }

        // top -> bottom
        for(int j = 0; j < n; j++){
            boolean seen = false;
            for(int i = 0; i < m; i++){
                if(grid[i][j] == 2) seen = false;
                else if(grid[i][j] == 1) seen = true;
                else if(seen) guarded[i][j] = true;
            }
        }

        // bottom -> top
        for(int j = 0; j < n; j++){
            boolean seen = false;
            for(int i = m - 1; i >= 0; i--){
                if(grid[i][j] == 2) seen = false;
                else if(grid[i][j] == 1) seen = true;
                else if(seen) guarded[i][j] = true;
            }
        }

        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(guarded[i][j] && grid[i][j] == 0) grid[i][j] = -1;
            }
        }
    }
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] grid = new int[m][n];
        for(int k = 0; k < guards.length; k++){
            grid[guards[k][0]][guards[k][1]] = 1;
        }

        for(int k = 0; k < walls.length; k++){
            grid[walls[k][0]][walls[k][1]] = 2;
        }

        markGuarded(grid, m, n);

        int unGuarded = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 0) unGuarded++;
            }
        }

        return unGuarded;
    }
}

// Approach 2
class Solution {
    private void helper(int[][] grid, int row, int col, int m, int n){
        // north
        for(int i = row - 1; i >= 0; i--){
            if(grid[i][col] == 2 || grid[i][col] == 1) break;
            grid[i][col] = -1;
        }

        // south
        for(int i = row + 1; i < m; i++){
            if(grid[i][col] == 2 || grid[i][col] == 1) break;
            grid[i][col] = -1;
        }

        // west
        for(int i = col - 1; i >= 0; i--){
            if(grid[row][i] == 2 || grid[row][i] == 1) break;
            grid[row][i] = -1;
        }

        // east
        for(int i = col + 1; i < n; i++){
            if(grid[row][i] == 2 || grid[row][i] == 1) break;
            grid[row][i] = -1;
        }
    }
    private void markGuarded(int[][] grid, int m, int n){
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 1){
                    helper(grid, i, j, m, n);
                }
            }
        }
    }
    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {
        int[][] grid = new int[m][n];
        for(int k = 0; k < guards.length; k++){
            grid[guards[k][0]][guards[k][1]] = 1;
        }

        for(int k = 0; k < walls.length; k++){
            grid[walls[k][0]][walls[k][1]] = 2;
        }

        // for(int i = 0; i < m; i++){
        //     for(int j = 0; j < n; j++){
        //         System.out.print(grid[i][j] + " ");
        //     }
        //     System.out.println();
        // }
        markGuarded(grid, m, n);

        int unGuarded = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(grid[i][j] == 0) unGuarded++;
            }
        }

        return unGuarded;
    }
}